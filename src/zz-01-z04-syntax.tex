\section{Syntax}
\label{security:syntax}
 
A proof system (for a relation $R$ defining a language $L$) is a protocol between a prover and a verifier sending messages to each other. 
The prover and verifier are defined by two algorithms, which we call Prove and Verify. 
The algorithms Prove and Verify may be probabilistic and may keep internal state between invocations.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection[Prove]{\textbf{Prove}$(state, m) \rightarrow (state, p)$}

The Prove algorithm in a given state receiving message $m$, updates its state and returns a message $p$.\loosen

\begin{itemize}
\item The initial state of Prove must include an instance $x$ and a witness $w$. 
	The initial state may also include additional setup information setup$_P$, e.g., $state = (setup_P, x, w)$.
\item If receiving a special initialization message $m = \tt start$ when first invoked it means the prover is to initiate the protocol.
\item If Prove outputs a special error symbol $p = \tt error$, it must output {\tt error} on all subsequent calls as well.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection[Verify]{\textbf{Verify}$(state, p)$ $\rightarrow (state, m)$}

The Verify algorithm in a given state receiving message $p$, updates its state and returns a message $m$.\loosen

\begin{itemize}
\item The initial state of Verify must include an instance $x$.
\item The initial state of Verify may also include additional setup information setup$_V$, e.g., $state = (setup_V,x)$.
\item If receiving a special initialization message $p = \tt start$, it means the verifier is to initiate the protocol.
\item If Verify outputs a special symbol $m = \tt accept$, it means the verifier accepts the proof of the statement $x \in L$. 
			In this case, Verify must return $m = \tt accept$ on all future calls.
\item If Verify outputs a special symbol $m = \tt reject$, it means the verifier rejects the proof of the statement $x \in L$. 
			In this case, Verify must return $m = \tt reject$ on all future calls.
\end{itemize}
 
	The setup information setup$_P$ and setup$_V$ can take many forms. 
	A common example found in the cryptographic literature is that setup$_P$ = setup$_V = k$, 
where $k$ is a security parameter indicating the desired security level of the proof system. 
	It is also conceivable that setup$_P$ and setup$_V$ contain descriptions of particular choices of primitives to instantiate the proof system with, e.g., to use the SHA-256 hash function or to use a particular elliptic curve. 
	The setup information may also be generated by a probabilistic process, e.g., 
it may be that setup$_P$ and setup$_V$ include a common reference string, 
or in the case of designated verifier proofs that setup$_P$ and setup$_V$ are correlated in a particular way. 
	When we want to specifically refer to this process, we use a probabilistic setup algorithm \textbf{Setup}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection[Setup]{\textbf{Setup}(parameters)\luissug{Consider using \emph{params} (in math mode) as the 
variable containing the ``parameters'', and using \emph{aux} (in math mode) instead of ``auxiliary output''. 
Notice that \emph{aux} is anyway used from \refsec{sec:security:defs-props:completeness} onward.} 
$\rightarrow$ (\setR, \setP, \setV, auxiliary output)}

The setup algorithm may take input parameters, which could for instance be computational or statistical security parameters indicating the desired security level of the proof system, or size parameters specifying the size of the statements the proof system should work for, or choices of cryptographic primitives e.g. the SHA-256 hash function or an elliptic curve.

\begin{itemize}
\item The setup algorithm returns an input \setR\ for the relation the proof system is for. An important special case is where the \setR\ is just the empty string, i.e., the relation is independent of any setup.
\item The setup algorithm returns \setP\ for the prover and \setV\ for the verifier.
\item There may potentially be additional auxiliary outputs.
\item If the inputs are malformed or any error occurs, the Setup algorithm may output an error symbol.
\end{itemize}


Some examples of possible setups.
\begin{itemize}

\item NIZK proof system for 3SAT in the uniform reference string model based on trapdoor permutations
		\begin{itemize}
		\item $\setR = n$, where $n$ specifies the maximal number of clauses
		\item $\setP = \setV$ = uniform random string of length $N = size(n,k)$ for some function $size(n,k)$ of $n$ and security parameter $k$
		\end{itemize}

\item Groth-Sahai proofs for pairing-product equations
	\begin{itemize}
	\item $\setR$ = description of bilinear group defining the language
	\item $\setP = \setV$ = common reference string including description of the bilinear group in \setR\ plus additional group elements
	\end{itemize}

\item SNARK for QAP such as e.g. Pinocchio
	\begin{itemize}
	\item \setR\ = QAP specification including finite field F and polynomials
	\item $\setP = \setV$ = common reference string including a bilinear group defined over the same finite field and some group elements

The prover and verifier do not use the same group elements in the common reference string. For efficiency reasons, one may let \setP\ be the subset of the group elements the prover uses, and \setV\ another (much smaller) subset of group elements the verifier uses.\loosen
	\end{itemize}

\item Cramer-Shoup hash proof systems
	\begin{itemize}
	\item \setR\ = specifies finite cyclic group of prime order
	\item \setP\ = the cyclic group and some group elements
	\item \setV\ = the cyclic group and some discrete logarithms
	\end{itemize}

\end{itemize}


It depends on the concrete setting how Setup runs. 
In some cases, a trusted third party runs an algorithm to generate the setup. 
In other cases, Setup may be a multi-party computation offering resilience against a subset of corrupt and dishonest parties (and the auxiliary output may represent side-information the adversarial parties learn from the MPC protocol). 
Yet, another possibility is to work in the plain model, where the setup does nothing but copy a security parameter, e.g., $\setP = \setV = k$.
 
There are variations of proof systems, e.g., multi-prover proof systems and commit-and-prove systems; this document only covers standard systems.
 
\textbf{Common reference string:} If the setup information is public and known to everybody, we say the proof system is in the common reference string model. 
The setup may for instance specify $\setR = \setP = \setV$, which we then refer to as a common reference string CRS.
 
\textbf{Non-interactive proof systems:} 
A proof system is non-interactive if the interaction consists of a single message from the prover to the verifier.
After receiving the prover’s message $p$\luiscom{Should it be \textbackslash pi?} (called a proof), the verifier then returns accept or reject.
 
\textbf{Public verifiability vs designated verifier:} 
If \setV\ is public information (e.g. in the CRS model) known to multiple parties in a non-interactive proof system, then they can all verify a proof $p$. 
In this case, the proof is transferable, the prover only needs to create it once after which it can be copied and transferred to many verifiers. 
If on the other hand, \setV\ is private we refer to it as a designated verifier proof system.
 
\textbf{Public coin:} 
In an interactive proof system, we say it is public coin if the verifier’s messages are uniformly random and independent of the prover’s messages.

